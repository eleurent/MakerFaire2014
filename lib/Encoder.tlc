%% File : Encoder.tlc

%implements Encoder "C"

%% Function: BlockTypeSetup ===============================================
%%
%function BlockTypeSetup(block, system) void
  %%
  %% The Target Language must be C
  %if ::GenCPP==1
    %<LibReportFatalError("This S-Function generated by the Legacy Code Tool must be only used with the C Target Language")>
  %endif

  %assign hdrFile = LibGetModelDotHFile()

  %openfile tmpBuf
  #include <Arduino.h>
  %closefile tmpBuf

  %<LibSetSourceFileSection(hdrFile,"Includes",tmpBuf)>
  
  %openfile tmpBuf
  typedef struct { int pinA; int pinB; long pos; int del;} Encoder; 
  %closefile tmpBuf

  %<LibSetSourceFileSection(hdrFile,"Typedefs",tmpBuf)>

  %%
%endfunction

%% Function: BlockInstanceSetup ===========================================
%%
%function BlockInstanceSetup(block, system) void
  %%
  %<LibBlockSetIsExpressionCompliant(block)>
  

    %assign name = LibGetBlockName(block)
    %assign blockName = FEVAL("regexprep", name, "[^A-z0-9]", "")
    
    %assign srcFile = LibGetModelDotCFile()

    %openfile tmpBuf
    volatile Encoder Enc_%<blockName> = {0,0,0,0};
    %closefile tmpBuf

    %<LibSetSourceFileSection(srcFile,"Declarations",tmpBuf)>

    %openfile tmpBuf

/* Interrupt Service Routine: change on pin A for Encoder 2  */
void isrPinAEn_%<blockName>(){

  /* read pin B right away */
  int drB = digitalRead(Enc_%<blockName>.pinB);
  
  /* possibly wait before reading pin A, then read it */  
  int drA = digitalRead(Enc_%<blockName>.pinA);

  /* this updates the counter */
  if (drA == HIGH) {   /* low->high on A? */
      
    if (drB == LOW) {  /* check pin B */
  	Enc_%<blockName>.pos++;  /* going clockwise: increment */
    } else {
  	Enc_%<blockName>.pos--;  /* going counterclockwise: decrement  */
    }
    
  } else { /* must be high to low on A */
  
    if (drB == HIGH) { /* check pin B */
  	Enc_%<blockName>.pos++;  /* going clockwise: increment */
    } else {
  	Enc_%<blockName>.pos--;  /* going counterclockwise: decrement  */
    }
    
  } /* end counter update */

} /* end ISR pin A Encoder 2 */


/* Interrupt Service Routine: change on pin B for Encoder 2  */
void isrPinBEn_%<blockName>(){ 

  /* read pin A right away */
  int drA = digitalRead(Enc_%<blockName>.pinA);
  
  /* possibly wait before reading pin B, then read it        */
  
  int drB = digitalRead(Enc_%<blockName>.pinB);

  /* this updates the counter */
  if (drB == HIGH) {   /* low->high on B? */
  
    if (drA == HIGH) { /* check pin A */
  	Enc_%<blockName>.pos++;  /* going clockwise: increment */
    } else {
  	Enc_%<blockName>.pos--;  /* going counterclockwise: decrement */
    }
  
  } else { /* must be high to low on B */
  
    if (drA == LOW) {  /* check pin A */
  	Enc_%<blockName>.pos++;  /* going clockwise: increment */
    } else {
  	Enc_%<blockName>.pos--;  /* going counterclockwise: decrement  */
    }
    
  } /* end counter update */

} /* end ISR pin B Encoder 2 */

  %closefile tmpBuf

  %<LibSetSourceFileSection(srcFile,"Functions",tmpBuf)>


  %%
%endfunction

%% Function: Start ========================================================
%%
%function Start(block, system) Output
  %%
  %assign p1_val = LibBlockParameter(p1, "", "", 0)
  %assign p2_val = LibBlockParameter(p2, "", "", 0)
  
  %%

    %assign name = LibGetBlockName(block)
    %assign blockName = FEVAL("regexprep", name, "[^A-z0-9]", "")

    Enc_%<blockName>.pinA=(int)%<p1_val>;      /* set pin A */
    Enc_%<blockName>.pinB=(int)%<p2_val>;      /* set pin B */

    /* set encoder pins as inputs */
    pinMode(Enc_%<blockName>.pinA, INPUT); 
    pinMode(Enc_%<blockName>.pinB, INPUT); 

    /* turn on pullup resistors */
    digitalWrite(Enc_%<blockName>.pinA, HIGH); 
    digitalWrite(Enc_%<blockName>.pinB, HIGH);

    attachInterrupt(Enc_%<blockName>.pinA, isrPinAEn_%<blockName>, CHANGE);
    attachInterrupt(Enc_%<blockName>.pinB, isrPinBEn_%<blockName>, CHANGE);

  %%
%endfunction

%% Function: Outputs ======================================================
%%
%function Outputs(block, system) Output
  %%
    %if !LibBlockOutputSignalIsExpr(0)
    %assign y1_val = LibBlockOutputSignal(0, "", "", 0)
    %%    
    %assign name = LibGetBlockName(block)
    %assign blockName = FEVAL("regexprep", name, "[^A-z0-9]", "")

    %<y1_val> = Enc_%<blockName>.pos;
    %endif 
  %%
%endfunction

%% Function: BlockOutputSignal ============================================
%%
%function BlockOutputSignal(block,system,portIdx,ucv,lcv,idx,retType) void
  %%
  %assign y1_val = LibBlockOutputSignal(0, "", "", 0)
  %%
  %switch retType
    %case "Signal"
      %if portIdx == 0
        %return "getEncoder( (uint8_T)%<p1_val>)"
      %else
        %assign errTxt = "Block output port index not supported: %<portIdx>"
        %<LibBlockReportError(block,errTxt)>
      %endif
    %default
      %assign errTxt = "Unsupported return type: %<retType>"
      %<LibBlockReportError(block,errTxt)>
  %endswitch
  %%
%endfunction

%% [EOF]
